# JVM: краткий курс общей анатомии

## План доклада

* Java class file and bytecode
* Classloading engine
* Execution engine: interpretators, JIT, AOT
* Meta information access subsystem: reflection, indy, JNI
* Threading, exception handling, synchraniztion
* Memeory Managment: heap, allocation, GC
* Manageability and Monitoring

## Java class file & bytecode

* Вообще Вы когда пишете свои программны программы на Java,
Вы их пишете на языке Java в исходных текстах, например в исходном тексте у Вас может быть нескольо объявлено классов, но прежде чем Вы можете исполнить свой код на JVM Вы должны их скомпилировать в виде класс-файлов с помощью компилятора javac и на выходе у Вас на каждый класс обяъявленный внутри вашего исходного файла должен родится отдельный класс-файл.

* Что такое класс-файл? Внутри класс-файл выглядит таким образом, что в начале идет так называемый constant-pool это всякие константы типа как числа, строки, так и более сложные указатели на классы, методы, поля далее идет собственно описание самого класса т.е. его имя, модификаторы, суперкласс, интерфейсы, поля, методы и любая дополнительная информация может кодироваться с помощью аттрибутов, например аннотаций.

* На полях на методах тоже есть аттрибуты, например когда Вы объявляете статическую константу в классе, на уровне байткода ее значение представляется в виде аттрибута и значение хранится в констант пулле, но главный аттрибут это все таки байткод, то что реально исполняется, то во что компилируется Ваша программа.

* JVM это стэковая виртуальная машина и для описания программы нужны три сущности:
    
    - Массив инструкций
    - Стэк операндов инструкций метода
    - Массив локальных переменных

## JVM предисловие

### Программа для JVM

* У каждой программы обязателньо должен быть main класс у которого есть main метод, который вы задаете при запуске своей программы и чтобы jvm могла нужный класс вы должны задать classpath, т.е. это список дирректорий и архивов где собственно JVM должна искать классы.

  - А что же с веб-приложениями, разве там есть main классы?

* Да вот действительно, в веб-приложениях вроде бы main класса нет, но в мире веб приложений программой для JVM является собственно веб-вервер на котором запускается веб-приложение и вот как раз у этого веб сервера есть main класс и classpath и т.д.

## Java Runtime

* Соответсвенно мы увидели с вам что есть байткод, но одного байткода не достаточно для исполнения программы. Соответсвенно VM она да исполняет байткод, но ваша программа чаще всего завязана на ряд платформаенных классов в Java очень богатая библиотека стандартных классов, Вы например никогда не реализуете свои String, они предоставляются вам реализацией платформы. Есть ряд стандартных API, например графика, AWT, Swing и для реализации такого рода подсистем требуется  возможность работы с платформой. В Java есть так называемые нативные методы т.е. вы можете объявить метод при вызове которого будет исполняться нативный код, код в некоторой платформенной библиотеке. Также в Java Runtime Environment есть ряд вспомогательных файлов например timezone и т.д. 

# Анатомия JVM

## Classloading engine 

### Загрузка классов

* Сначала нужно разобраться вообще откуда JVM берет классы для исполнения, во первых у нас есть платформенные классы, они берутся из java runtime, классы вашего приложения берутся из classpath, некоторые классы могут появлятся только во время исполнения их может генерить как Java Runtime так и билиотеки котроые вы используете и само ваше приложение может предоставить JVM классы посредством так называемых загрузчиков классов.
Вообще в JVM в каждый класс грузится некоторым загрузчиком классов, платформенные классы грузятся bootstrap загрузчиком, классы из classpath грузятся системным загрузчиком (AppClassLoader), классы приложения могут создавать свои загрузчики, которые также могут грузить классы.

* Может ли в JVM загружены классы с двумя одинаковыми именами, правильный ответ да. Потому что в JVM классы идентифицируются не по имени а по паре, имя-загрузчик классов. И таким образом загрузчик классов образует уникальное пространство имен  классов внутри JVM. 
