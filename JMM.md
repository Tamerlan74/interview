# Stack vs Heap

1. [Что такое stack?](#Что-такое-stack?)
2. [Что такое heap?](#Что-такое-heap?)
3. [Как в течение вего жизненного цикла выделяется и освобождается память в стеке?](#Как-в-течение-вего-жизненного-цикла-выделяется-и-освобождается-память-в-стеке?)
4. [Когда освобождается стековая память?](#Когда-освобождается-стековая-память?)
5. [Когда освобождается heap память?](#Когда-освобождается-heap-память?)
6. [Почему выделение памяти в стеке происходит быстрее, чем в куче?](#Почему-выделение-памяти-в-стеке-происходит-быстрее,-чем-в-куче?)

# Ответы для Stack vs Heap

1. ### Что такое stack?

Стек - это память, связанная с каждым системным потоком при его создании.

[на верх](#Stack-vs-Heap)

2. ### Что такое heap?

куча используется всеми потоками в приложении

[на верх](#Stack-vs-Heap)

3. ### Как в течение вего жизненного цикла выделяется и освобождается память в стеке?

Для каждой функции, которую посещает поток, наверху стека выделяется блок памяти для локальных переменных и регистрационных данных, которые освобождаются при возврате из этой функции в порядке LIFO.

[на верх](#Stack-vs-Heap)

4. ### Когда освобождается стековая память?

Когда поток завершается, стек, связанный с потоком, освобождается.

[на верх](#Stack-vs-Heap)

5. ### Когда освобождается heap память?

Когда приложение в рантайме, память кучи освобождается

[на верх](#Stack-vs-Heap)

6. ### Почему выделение памяти в стеке происходит быстрее, чем в куче?

Выделение и освобождение памяти стека проще и быстрее, так как это так же просто, как настройка указателя. Выделение и освобождение памяти в Heap сравнительно сложны, поскольку нет фиксированного шаблона распределения памяти.

# Heap fragmentation

1. [Что такое heap fragmentation?](#Что-такое-heap-fragmentation?)
2. [Как можно контроллировать heap fragmentation?](#Как-можно-контроллировать-heap-fragmentation?)
3. [Что такое сериализация?](#Что-такое-сериализация?)

# Garbage Collection

1. [Что такое GC?](#Что-такое-GC?)

# Ответы на тему Garbage Collection

1. ### Что такое GC?

Сборка мусора в Java - это процесс идентификации и удаления из памяти объектов, на которые нет ссылок, а также перемещения оставшихся объектов вместе для освобождения непрерывного блока памяти.

[на верх](#Garbage-Collection)

# Ответы на тему Heap fragmentation

1. ### Что такое heap fragmentation?

Перераспределение памяти
Фрагментация кучи происходит, когда приложение Java выделяет и освобождает малые и большие блоки памяти в течение определенного периода, что приводит к тому, что множество маленьких свободных блоков памяти распределяются между используемыми блоками памяти.

[на верх](#Heap-fragmentation)

2. ### Как можно контроллировать heap fragmentation?

Избегание выделения большого блока памяти путем увеличения размера кучи и т. Д. Может контролировать фрагментацию кучи.

[на верх](#Heap-fragmentation)

3. ### Что такое сериализация?

Преобразование содержимого объекта в памяти в байты для его сохранения или передачи называется сериализацией объекта.

[на верх](#Heap-fragmentation)




1. Что означает выражение "Память менеджится в java"?

в Java разработчику не нужно явно выделять и освобождать память - JVM и, в частности, сборщик мусора - отвечает за выделение и освобождение памяти, так что разработчику этого не нужно.

2. Что такое GC и какие есть преимущества?

Сборка мусора - это процесс просмотра памяти кучи, определения того, какие объекты используются, а какие нет, и удаления неиспользуемых объектов.

Используемый объект или объект, на который имеется ссылка, означает, что некоторая часть вашей программы все еще поддерживает указатель на этот объект. На неиспользуемый объект или объект, на который нет ссылок, больше не ссылается какая-либо часть вашей программы. Таким образом, можно освободить память, используемую объектом, на который нет ссылки.

Самым большим преимуществом сборки мусора является то, что она снимает с нас бремя ручного выделения / освобождения памяти, чтобы мы могли сосредоточиться на решении возникшей проблемы.

3. Какие есть недостатки использования GC?

Каждый раз, когда запускается сборщик мусора, он влияет на производительность приложения. Это связано с тем, что все другие потоки в приложении должны быть остановлены, чтобы поток сборщика мусора мог эффективно выполнять свою работу.

В зависимости от требований приложения это может быть реальной проблемой, неприемлемой для клиента. Однако эту проблему можно значительно уменьшить или даже устранить путем умелой оптимизации и настройки сборщика мусора, а также использования различных алгоритмов сборки мусора.

4. Что означает stop-the-world?

Когда поток сборщика мусора работает, другие потоки останавливаются, то есть приложение останавливается на мгновение.

5. Что такое стек и куча? Что хранится в каждой из этих структур памяти и как они взаимосвязаны?

Стек - это часть памяти, которая содержит информацию о вызовах вложенных методов до текущей позиции в программе. Он также содержит все локальные переменные и ссылки на объекты в куче, определенные в выполняемых в данный момент методах.
Эта структура позволяет среде выполнения возвращаться из метода, зная адрес, по которому он был вызван, а также очищать все локальные переменные после выхода из метода. У каждого потока есть свой стек.

Куча - это большой объем памяти, предназначенный для размещения объектов. Когда вы создаете объект с ключевым словом new, он выделяется в куче. Однако ссылка на этот объект живет в стеке.

6. Что такое Generation в GC и что делает ее популярным подходом к сборке мусора?

Сборку мусора по поколениям можно в общих чертах определить как стратегию, используемую сборщиком мусора, при которой куча делится на несколько разделов, называемых поколениями, каждая из которых будет содержать объекты в куче в соответствии с их «возрастом».

7. Опиши в деталях как работает generational GC?

Молодое поколение является хозяином большинства вновь созданных объектов. Эмпирическое исследование большинства приложений показывает, что большинство объектов быстро недолговечны и поэтому вскоре становятся пригодными для сбора. Таким образом, новые объекты начинают свой путь здесь и «продвигаются» в пространство старых поколений только по достижении определенного «возраста».

Термин «возраст» в поколенческой сборке мусора относится к количеству циклов сборки, которые объект пережил.

Пространство молодого поколения разделено на три области: пространство Эдема и два пространства выживших, таких как Выживший 1 (s1) и Выживший 2 (s2).

Старое поколение содержит объекты, которые прожили в памяти дольше определенного «возраста». В это пространство продвигаются объекты, пережившие сборку мусора от молодого поколения. Это вообще больше, чем молодое поколение. Поскольку он больше по размеру, сборка мусора обходится дороже и происходит реже, чем у молодого поколения.

Постоянная генерация, или более часто называемая PermGen, содержит метаданные, необходимые JVM для описания классов и методов, используемых в приложении. Он также содержит пул строк для хранения интернированных строк. Он заполняется JVM во время выполнения на основе классов, используемых приложением. Кроме того, здесь могут храниться классы и методы библиотеки платформы.

Во-первых, любые новые объекты размещаются в пространстве Эдема. Обе ячейки выживших начинаются пустыми. Когда пространство Eden заполняется, запускается небольшая сборка мусора. Связанные объекты перемещаются в первую оставшуюся ячейку. Объекты, на которые нет ссылок, удаляются.

Во время следующего второстепенного сборщика мусора то же самое происходит с пространством Эдема. Объекты, на которые нет ссылок, удаляются, а объекты, на которые есть ссылки, перемещаются в оставшееся пространство. Однако в этом случае они перемещаются во вторую ячейку выживших (S2).

Кроме того, возраст объектов из последнего второстепенного сборщика мусора в первом выжившем пространстве (S1) увеличивается, и они перемещаются в S2. Как только все уцелевшие объекты будут перемещены в S2, пространство S1 и Eden очищается. На данный момент S2 содержит объекты разного возраста.

На следующем второстепенном GC тот же процесс повторяется. Однако на этот раз клетки выживших меняются. Связанные объекты перемещаются в S1 как из Eden, так и из S2. Уцелевшие объекты состарились. Eden и S2 очищены.

После каждого незначительного цикла сборки мусора проверяется возраст каждого объекта. Те, кто достигли определенного произвольного возраста, например, 8 лет, переходят из молодого поколения в старое или постоянное поколение. Для всех последующих второстепенных циклов сборки мусора объекты будут по-прежнему перемещаться в пространство старого поколения.

Это в значительной степени исчерпывает процесс сборки мусора у молодого поколения. В конце концов, основная сборка мусора будет выполнена на старом поколении, которое очистит и уплотнит это пространство. Для каждого основного сборщика мусора существует несколько второстепенных сборщиков мусора.